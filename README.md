# MakeLink

[![Build Status](https://dev.azure.com/michaelbosschert/MakeLink/_apis/build/status/Michron.MakeLink?branchName=main)](https://dev.azure.com/michaelbosschert/MakeLink/_build/latest?definitionId=2&branchName=main)

MakeLink is a utility library that provides functionality for creating file system links. Currently only Directory Junctions are supported, and can only be created on NTSF file systems on Windows. Support for symbolic links and hard links has not been added yet.

## Main contents

* [Quick Start](#quick-start)
* [How It Works](#how-it-works)
* [Changelog](Changelog.md)

## Quick Start

MakeLink can be used in various ways, but the easiest are the following:

* Add a `PackageReference` to the `MakeLink` nuget package (recommended).
* Add a `ProjectReference` in your own project for `src\MakeLink\MakeLink.csproj` by cloning the repository, or by adding it as a submodule in your own repository.

### Installation

> **NOTE**: Global nuget package is not yet available. To add the package reference, the nuget has to be created manually and added to a custom nuget feed.

```bash
dotnet add package MakeLink
```

### Usage

To manage Junction Directories, the `MakeLink.JunctionLink` class can be used. It allows you to create, delete, and inspect Junction Directories.

Creating a Junction Directory can be done via `MakeLink.JunctionLink.Create`. This will create a Junction link from `link` to `target`, allowing two locations to share the same files.

```cs
string link = "C:\Foo";
string target = "C:\Bar";

MakeLink.JunctionLink.Create(link, target);
```

Deleting a Junction Directory is achieved by using `MakeLink.JunctionLink.Delete`. This will only delete the Junction Directory. The original target directory will not be deleted.

```cs
string link = "C:\Foo";

MakeLink.JunctionLink.Delete(link);
```

Existing Junction Directories can also be inspected with `MakeLink.JunctionLink.Exists` and `MakeLink.JunctionLink.GetTarget`.

```cs
string link = "C:\Foo";
string target = "C:\Bar";

MakeLink.JunctionLink.Create(link, target);

bool exists = MakeLink.JunctionLink.Exists(link);
string? junctionTarget = MakeLink.JunctionLink.GetTarget(link);

Console.WriteLine($"Exists: {exists}");
Console.WriteLine($"Target: {junctionTarget}");

// Output
// Exists: True
// Target: C:\Bar
```

## How It Works

To access and manage Junction Directories, a `ReparsePoint` is opened by invoking native Windows functions (`CreateFileW`). This `ReparsePoint` is then modified using a `ReparseDataBuffer` which contains the data describing how the `ReparsePoint` should be modified (eg. create, or delete).

Native methods are invoked via the `PInvoke` class that's generated by [CsWin32](https://github.com/microsoft/CsWin32) source generator.

## Issues & Contributions

If you find a bug or have a feature request, please report them at this repository's issues section. Contributions via pull requests to add features or fix issues are welcome.

## Code of Conduct

This project has adopted the code of conduct defined by the Contributor Covenant
to clarify expected behavior in our community.

For more information, see the [.NET Foundation Code of Conduct](https://dotnetfoundation.org/code-of-conduct).

## Credits

This project is inspired by the article from CodeProject user [jeff.brown](https://www.codeproject.com/script/Membership/View.aspx?mid=1994253) in his post [Manipulating NTFS Junction Points in .NET](https://www.codeproject.com/Articles/15633/Manipulating-NTFS-Junction-Points-in-NET).

## License

This project is licensed under the MIT license. See the [LICENSE](LICENSE) file for more info.
